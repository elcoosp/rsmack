//! # Edoc Procedural Macro
//!
//! This module implements a procedural macro called `edoc` (documentation macro) that generates
//! documentation for struct fields by concatenating string literals and constants.
//!
//! ## Overview
//!
//! The `edoc` macro processes struct fields with `#[edoc]` attributes, evaluates expressions
//! containing string literals and constant references, and replaces them with standard `#[doc]`
//! attributes containing the concatenated documentation strings.
//!
//! ## Usage Example
//!
//! ```rust,ignore
//! // In constants.rs
//! const PREFIX: &str = "MyApp";
//! const VERSION: &str = "1.0";
//!
//! // In struct definition
//! #[edoc(from = constants)]
//! struct MyStruct {
//!     #[edoc(("API version: ", VERSION))]
//!     version: String,
//!
//!     #[edoc(("Application: ", PREFIX, " - Main service"))]
//!     name: String,
//! }
//! ```
//!
//! This expands to:
//! ```rust,ignore
//! struct MyStruct {
//!     #[doc = "API version: 1.0"]
//!     version: String,
//!
//!     #[doc = "Application: MyApp - Main service"]
//!     name: String,
//! }
//! ```

use darling::{ast, FromDeriveInput, FromField, FromMeta, FromVariant};
use proc_macro2::TokenStream;
use quote::*;
use rsmack_utils::{fs::package_src_folder, megamac::ExecEnv};
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead};
use syn::*;

/// Represents the expression to evaluate for documentation concatenation
///
/// Contains a tuple expression with string literals and constant identifiers
/// that will be concatenated to form the final documentation string.
#[derive(Debug, FromMeta)]
pub struct EdocFieldConcat {
    /// The tuple expression containing string literals and constant identifiers
    /// to be concatenated into the final documentation string
    expr: syn::Expr,
}

/// Represents a field or variant with an `edoc` attribute
///
/// Processes `#[edoc(...)]` attributes on struct fields and enum variants,
/// extracting the concatenation expression for evaluation.
#[derive(Debug, FromField, FromVariant)]
#[darling(attributes(edoc))]
pub struct EdocField {
    /// Concatenate members of [`syn::ExprTuple`] which maybe either [`syn::LitStr`] or a const [`syn::Ident`].
    /// Return a `#[doc]` attribute
    #[darling(flatten)]
    concat: EdocFieldConcat,
}

/// Macro arguments specifying where to find constants for documentation
///
/// Used as `#[edoc(from = path::to::module)]` to specify the module path
/// containing the constants referenced in edoc expressions.
#[derive(Debug, FromMeta)]
pub struct Args {
    /// The [`syn::Path`] to the module (`self` not handled) you want to pull constants from
    from: syn::Path,
}

/// Parses the main derive input with `edoc` attributes
///
/// Processes the struct/enum definition and extracts all fields/variants
/// that have `edoc` attributes for documentation generation.
#[derive(Debug, FromDeriveInput)]
#[darling(attributes(edoc), forward_attrs(allow, doc, cfg))]
pub struct DeriveInputArgs {
    /// The data of the derive input (struct fields or enum variants)
    data: ast::Data<EdocField, EdocField>,
}

/// Reads a file line by line and returns an iterator over the lines
///
/// # Arguments
/// * `filename` - Path to the file to read
///
/// # Returns
/// * `io::Result<io::Lines<io::BufReader<File>>>` - Iterator over lines of the file
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<std::path::Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}

/// Removes specified attributes from struct fields and replaces them with new attributes
///
/// This function processes each field in a struct, finds attributes with the specified names,
/// removes them, and replaces them with new attributes generated by the `replace_with` closure.
///
/// # Type Parameters
/// * `R` - Closure type that generates replacement attributes
///
/// # Arguments
/// * `attrs_to_remove` - List of attribute names to remove (e.g., `["edoc"]`)
/// * `item` - The struct item to process
/// * `replace_with` - Closure that generates replacement attributes based on field and removal count
///
/// # Returns
/// * `ItemStruct` - The struct with specified attributes replaced
fn rm_item_fields_attrs<
    R: Fn(
        &mut Field,
        &String,
        // Removed count
        usize,
    ) -> Attribute,
>(
    attrs_to_remove: Vec<String>,
    item: &mut ItemStruct,
    replace_with: R,
) -> ItemStruct {
    for attr_to_rm in &attrs_to_remove {
        let mut removed_count: usize = 0;
        for field in &mut item.fields {
            let attr_to_rm_idx = field.attrs.iter().position(|a| match a {
                Attribute {
                    meta: Meta::List(MetaList { path, .. }),
                    ..
                } => {
                    let id = path.segments.first().unwrap().ident.clone();
                    &id.to_string() == attr_to_rm
                }
                _ => false,
            });
            if let Some(i) = attr_to_rm_idx {
                let replacement_attr = replace_with(field, attr_to_rm, removed_count);
                field.attrs[i] = replacement_attr;
                removed_count += 1;
            };
        }
    }
    item.clone()
}

/// Main macro execution function
///
/// Processes the struct with `edoc` attributes by:
/// 1. Parsing input and extracting `edoc` attributes
/// 2. Resolving constants from the specified module
/// 3. Evaluating tuple expressions in `edoc` attributes
/// 4. Replacing `edoc` attributes with `doc` attributes containing concatenated strings
///
/// # Arguments
/// * `args` - Macro arguments specifying where to find constants
/// * `item` - The struct item to process
/// * `env` - Macro execution environment for error reporting and utilities
///
/// # Returns
/// * `TokenStream` - The transformed struct with generated documentation attributes
///
/// # Panics
/// * If macro arguments cannot be parsed
/// * If unsupported expression types are encountered
/// * If file reading fails
/// * If constant resolution fails
pub fn exec(args: Args, item: ItemStruct, env: ExecEnv) -> TokenStream {
    let derive_input = syn::parse2::<syn::DeriveInput>(item.to_token_stream()).unwrap();
    let call_site_file_path = call_site_file_path_from_syn_path(args.from);
    let derive_args = match DeriveInputArgs::from_derive_input(&derive_input) {
        Ok(args) => args,
        Err(e) => env
            .logr
            .abort_call_site(format!("Failed to parse macro args: {e}")),
    };

    let derive_args_data = derive_args.data.take_struct();
    let mut evaluated_edoc_fields: Vec<String> = vec![];
    if let Some(fields) = derive_args_data {
        let mut resolved_consts: HashMap<String, String> = HashMap::new();
        resolve_consts(call_site_file_path, &mut resolved_consts, &env);
        for edoc_field in fields {
            let mut evaluated_elems: Vec<String> = vec![];
            match edoc_field.concat.expr {
                Expr::Tuple(tup) => {
                    // Evaluate each element in the tuple expression
                    for elem in tup.elems {
                        match elem {
                        Expr::Lit(ExprLit {
                            lit: Lit::Str(lit @ LitStr { .. }),
                            ..
                        }) => {
                            // String literal - use its value directly
                            evaluated_elems.push(lit.value());
                        }
                        Expr::Path(ExprPath {
                            path: Path { segments, .. },
                            ..
                        }) => {
                            // Constant identifier - look up its resolved value
                            let const_ident = segments.first().unwrap().ident.clone();
                            let const_value = resolved_consts.get(&const_ident.to_string());
                            match const_value {
                                None => env.logr.emit_error(const_ident.span(),format!("Unresolved const ident {const_ident:?}")),
                                Some(value) => evaluated_elems.push(value.clone())
                            }

                        }
                        _ => env.logr.abort_call_site(
                            "Unsupported tuple element, only string literal or ident of a const string",
                        ),
                    }
                    }
                }
                _ => env.logr.abort_call_site(
                    "Only Tuple supported, maybe you are missing a second element".to_string(),
                ),
            }
            let sep = ""; // No separator - concatenate strings directly
            let evaluated = evaluated_elems.join(sep);
            evaluated_edoc_fields.push(evaluated);
        }
    }

    // Closure to generate replacement #[doc] attributes
    let field_attr_replacer = |_field: &mut Field, _attr_name: &String, attr_to_rm_idx: usize| {
        let doc_str = &evaluated_edoc_fields[attr_to_rm_idx];
        syn::parse_quote! {#[doc = #doc_str]}
    };
    let edoc_replaced_item =
        rm_item_fields_attrs(vec!["edoc".into()], &mut item.clone(), field_attr_replacer);
    quote! {
        #edoc_replaced_item
    }
}

/// Converts a module path to a file system path
///
/// Transforms a Rust module path (e.g., `my_module::submodule`) to a file system path
/// by converting `::` to `/` and appending `.rs` extension.
///
/// # Arguments
/// * `path` - The module path to convert
///
/// # Returns
/// * `std::path::PathBuf` - The corresponding file system path
fn call_site_file_path_from_syn_path(path: syn::Path) -> std::path::PathBuf {
    package_src_folder().join(format!(
        "{}.rs",
        path.to_token_stream().to_string().replace("::", "/")
    ))
}

/// Reads and parses constants from a source file
///
/// This function reads the specified source file line by line, identifies `const` declarations,
/// and extracts their values for supported literal types (strings, booleans, byte strings).
/// The resolved constants are stored in a HashMap for lookup during documentation generation.
///
/// # Supported Constant Types
/// * `&str` string slices
/// * `bool` boolean values
/// * `&[u8]` byte arrays (converted to debug format)
///
/// # Arguments
/// * `call_site_file_path` - Path to the source file containing constants
/// * `resolved_consts` - HashMap to store resolved constant names and values
/// * `env` - Execution environment for error reporting
///
/// # Limitations
/// * Currently does not support complex constant expressions like `concat!` macros
/// * Requires constants to be defined as simple literals
fn resolve_consts(
    call_site_file_path: std::path::PathBuf,
    resolved_consts: &mut HashMap<String, String>,
    env: &ExecEnv,
) {
    // TODO: This should be memoized to avoid reading the same file multiple times
    if let Ok(lines) = read_lines(call_site_file_path) {
        for line_read in lines {
            match line_read {
                Ok(line) => {
                    const CONST_KW: &str = "const";
                    let trimmed_line = line.trim();
                    if trimmed_line.starts_with(CONST_KW) {
                        let parsed_const_item: syn::ItemConst =
                            syn::parse_str(&line.clone()).unwrap();
                        let const_name = parsed_const_item.ident.to_string();
                        match *parsed_const_item.expr {
                            Expr::Lit(ExprLit { lit:Lit::Str(lit @ LitStr {..}),.. }) => {
                                // String constant - store its value
                                let _ = resolved_consts.insert(const_name,lit.value());
                            },
                            Expr::Lit(ExprLit { lit:Lit::Bool(lit @ LitBool {..}),.. }) => {
                                // Boolean constant - convert to string
                                let _ = resolved_consts.insert(const_name,lit.value().to_string());
                            },
                            Expr::Lit(ExprLit { lit:Lit::ByteStr(lit @ LitByteStr {..}),.. }) => {
                                // Byte string constant - format as debug string
                                let _ = resolved_consts.insert(const_name,format!("{:?}",lit.value()));
                            },
                            x => env.logr.abort_call_site(format!(
                                "Unexpected const item expression here, expected literal or `concat!` (NOT YET SUPPORTED) invocation, received: `{x:?}` at `{line}`"
                            )),
                        }
                    }
                }
                Err(e) => env
                    .logr
                    .abort_call_site(format!("Failed to read line: {e:?}")),
            }
        }
    }
}
